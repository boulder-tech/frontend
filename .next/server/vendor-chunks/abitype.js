"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/abitype";
exports.ids = ["vendor-chunks/abitype"];
exports.modules = {

/***/ "(ssr)/./node_modules/abitype/dist/chunk-NHABU752.mjs":
/*!******************************************************!*\
  !*** ./node_modules/abitype/dist/chunk-NHABU752.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __publicField: () => (/* binding */ __publicField)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2NodW5rLU5IQUJVNzUyLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0M7SUFDN0JILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7SUFDL0QsT0FBT0E7QUFDVDtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2NodW5rLU5IQUJVNzUyLm1qcz9lMDlhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZXhwb3J0IHtcbiAgX19wdWJsaWNGaWVsZFxufTtcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/abitype/dist/chunk-NHABU752.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/abitype/dist/chunk-WP7KDV47.mjs":
/*!******************************************************!*\
  !*** ./node_modules/abitype/dist/chunk-WP7KDV47.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   execTyped: () => (/* binding */ execTyped),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   isTupleRegex: () => (/* binding */ isTupleRegex)\n/* harmony export */ });\n// src/regex.ts\nfunction execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\nvar bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\nvar integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nvar isTupleRegex = /^\\(.+?\\).*?$/;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2NodW5rLVdQN0tEVjQ3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsZUFBZTtBQUNmLFNBQVNBLFVBQVVDLEtBQUssRUFBRUMsTUFBTTtJQUM5QixNQUFNQyxRQUFRRixNQUFNRyxJQUFJLENBQUNGO0lBQ3pCLE9BQU9DLE9BQU9FO0FBQ2hCO0FBQ0EsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLGVBQWU7QUFPakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvY2h1bmstV1A3S0RWNDcubWpzPzliOGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3JlZ2V4LnRzXG5mdW5jdGlvbiBleGVjVHlwZWQocmVnZXgsIHN0cmluZykge1xuICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgcmV0dXJuIG1hdGNoPy5ncm91cHM7XG59XG52YXIgYnl0ZXNSZWdleCA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xudmFyIGludGVnZXJSZWdleCA9IC9edT9pbnQoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcbnZhciBpc1R1cGxlUmVnZXggPSAvXlxcKC4rP1xcKS4qPyQvO1xuXG5leHBvcnQge1xuICBleGVjVHlwZWQsXG4gIGJ5dGVzUmVnZXgsXG4gIGludGVnZXJSZWdleCxcbiAgaXNUdXBsZVJlZ2V4XG59O1xuIl0sIm5hbWVzIjpbImV4ZWNUeXBlZCIsInJlZ2V4Iiwic3RyaW5nIiwibWF0Y2giLCJleGVjIiwiZ3JvdXBzIiwiYnl0ZXNSZWdleCIsImludGVnZXJSZWdleCIsImlzVHVwbGVSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/abitype/dist/chunk-WP7KDV47.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/abitype/dist/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/abitype/dist/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   narrow: () => (/* binding */ narrow),\n/* harmony export */   parseAbi: () => (/* binding */ parseAbi),\n/* harmony export */   parseAbiItem: () => (/* binding */ parseAbiItem),\n/* harmony export */   parseAbiParameter: () => (/* binding */ parseAbiParameter2),\n/* harmony export */   parseAbiParameters: () => (/* binding */ parseAbiParameters)\n/* harmony export */ });\n/* harmony import */ var _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-WP7KDV47.mjs */ \"(ssr)/./node_modules/abitype/dist/chunk-WP7KDV47.mjs\");\n/* harmony import */ var _chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-NHABU752.mjs */ \"(ssr)/./node_modules/abitype/dist/chunk-NHABU752.mjs\");\n\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n// src/errors.ts\nvar BaseError = class extends Error {\n    constructor(shortMessage, args = {}){\n        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\n        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n        const message = [\n            shortMessage || \"An error occurred.\",\n            \"\",\n            ...args.metaMessages ? [\n                ...args.metaMessages,\n                \"\"\n            ] : [],\n            ...docsPath ? [\n                `Docs: https://abitype.dev${docsPath}`\n            ] : [],\n            ...details ? [\n                `Details: ${details}`\n            ] : [],\n            `Version: ${name}@${version}`\n        ].join(\"\\n\");\n        super(message);\n        (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"details\");\n        (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"docsPath\");\n        (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"metaMessages\");\n        (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"shortMessage\");\n        (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"name\", \"AbiTypeError\");\n        if (args.cause) this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n};\n// src/narrow.ts\nfunction narrow(value) {\n    return value;\n}\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n    return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n    return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(errorSignatureRegex, signature);\n}\nvar eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n    return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n    return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(eventSignatureRegex, signature);\n}\nvar functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n    return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n    return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n    return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n    return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(structSignatureRegex, signature);\n}\nvar constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n    return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n    return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n    return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n    return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */ new Set([\n    \"memory\",\n    \"indexed\",\n    \"storage\",\n    \"calldata\"\n]);\nvar eventModifiers = /* @__PURE__ */ new Set([\n    \"indexed\"\n]);\nvar functionModifiers = /* @__PURE__ */ new Set([\n    \"calldata\",\n    \"memory\",\n    \"storage\"\n]);\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n    if (type) return `${type}:${param}`;\n    return param;\n}\nvar parameterCache = /* @__PURE__ */ new Map([\n    // Unnamed\n    [\n        \"address\",\n        {\n            type: \"address\"\n        }\n    ],\n    [\n        \"bool\",\n        {\n            type: \"bool\"\n        }\n    ],\n    [\n        \"bytes\",\n        {\n            type: \"bytes\"\n        }\n    ],\n    [\n        \"bytes32\",\n        {\n            type: \"bytes32\"\n        }\n    ],\n    [\n        \"int\",\n        {\n            type: \"int256\"\n        }\n    ],\n    [\n        \"int256\",\n        {\n            type: \"int256\"\n        }\n    ],\n    [\n        \"string\",\n        {\n            type: \"string\"\n        }\n    ],\n    [\n        \"uint\",\n        {\n            type: \"uint256\"\n        }\n    ],\n    [\n        \"uint8\",\n        {\n            type: \"uint8\"\n        }\n    ],\n    [\n        \"uint16\",\n        {\n            type: \"uint16\"\n        }\n    ],\n    [\n        \"uint24\",\n        {\n            type: \"uint24\"\n        }\n    ],\n    [\n        \"uint32\",\n        {\n            type: \"uint32\"\n        }\n    ],\n    [\n        \"uint64\",\n        {\n            type: \"uint64\"\n        }\n    ],\n    [\n        \"uint96\",\n        {\n            type: \"uint96\"\n        }\n    ],\n    [\n        \"uint112\",\n        {\n            type: \"uint112\"\n        }\n    ],\n    [\n        \"uint160\",\n        {\n            type: \"uint160\"\n        }\n    ],\n    [\n        \"uint192\",\n        {\n            type: \"uint192\"\n        }\n    ],\n    [\n        \"uint256\",\n        {\n            type: \"uint256\"\n        }\n    ],\n    // Named\n    [\n        \"address owner\",\n        {\n            type: \"address\",\n            name: \"owner\"\n        }\n    ],\n    [\n        \"address to\",\n        {\n            type: \"address\",\n            name: \"to\"\n        }\n    ],\n    [\n        \"bool approved\",\n        {\n            type: \"bool\",\n            name: \"approved\"\n        }\n    ],\n    [\n        \"bytes _data\",\n        {\n            type: \"bytes\",\n            name: \"_data\"\n        }\n    ],\n    [\n        \"bytes data\",\n        {\n            type: \"bytes\",\n            name: \"data\"\n        }\n    ],\n    [\n        \"bytes signature\",\n        {\n            type: \"bytes\",\n            name: \"signature\"\n        }\n    ],\n    [\n        \"bytes32 hash\",\n        {\n            type: \"bytes32\",\n            name: \"hash\"\n        }\n    ],\n    [\n        \"bytes32 r\",\n        {\n            type: \"bytes32\",\n            name: \"r\"\n        }\n    ],\n    [\n        \"bytes32 root\",\n        {\n            type: \"bytes32\",\n            name: \"root\"\n        }\n    ],\n    [\n        \"bytes32 s\",\n        {\n            type: \"bytes32\",\n            name: \"s\"\n        }\n    ],\n    [\n        \"string name\",\n        {\n            type: \"string\",\n            name: \"name\"\n        }\n    ],\n    [\n        \"string symbol\",\n        {\n            type: \"string\",\n            name: \"symbol\"\n        }\n    ],\n    [\n        \"string tokenURI\",\n        {\n            type: \"string\",\n            name: \"tokenURI\"\n        }\n    ],\n    [\n        \"uint tokenId\",\n        {\n            type: \"uint256\",\n            name: \"tokenId\"\n        }\n    ],\n    [\n        \"uint8 v\",\n        {\n            type: \"uint8\",\n            name: \"v\"\n        }\n    ],\n    [\n        \"uint256 balance\",\n        {\n            type: \"uint256\",\n            name: \"balance\"\n        }\n    ],\n    [\n        \"uint256 tokenId\",\n        {\n            type: \"uint256\",\n            name: \"tokenId\"\n        }\n    ],\n    [\n        \"uint256 value\",\n        {\n            type: \"uint256\",\n            name: \"value\"\n        }\n    ],\n    // Indexed\n    [\n        \"event:address indexed from\",\n        {\n            type: \"address\",\n            name: \"from\",\n            indexed: true\n        }\n    ],\n    [\n        \"event:address indexed to\",\n        {\n            type: \"address\",\n            name: \"to\",\n            indexed: true\n        }\n    ],\n    [\n        \"event:uint indexed tokenId\",\n        {\n            type: \"uint256\",\n            name: \"tokenId\",\n            indexed: true\n        }\n    ],\n    [\n        \"event:uint256 indexed tokenId\",\n        {\n            type: \"uint256\",\n            name: \"tokenId\",\n            indexed: true\n        }\n    ]\n]);\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature, structs = {}) {\n    if (isFunctionSignature(signature)) {\n        const match = execFunctionSignature(signature);\n        if (!match) throw new BaseError(\"Invalid function signature.\", {\n            details: signature\n        });\n        const inputParams = splitParameters(match.parameters);\n        const inputs = [];\n        const inputLength = inputParams.length;\n        for(let i = 0; i < inputLength; i++){\n            inputs.push(parseAbiParameter(inputParams[i], {\n                modifiers: functionModifiers,\n                structs,\n                type: \"function\"\n            }));\n        }\n        const outputs = [];\n        if (match.returns) {\n            const outputParams = splitParameters(match.returns);\n            const outputLength = outputParams.length;\n            for(let i = 0; i < outputLength; i++){\n                outputs.push(parseAbiParameter(outputParams[i], {\n                    modifiers: functionModifiers,\n                    structs,\n                    type: \"function\"\n                }));\n            }\n        }\n        return {\n            name: match.name,\n            type: \"function\",\n            stateMutability: match.stateMutability ?? \"nonpayable\",\n            inputs,\n            outputs\n        };\n    }\n    if (isEventSignature(signature)) {\n        const match = execEventSignature(signature);\n        if (!match) throw new BaseError(\"Invalid event signature.\", {\n            details: signature\n        });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for(let i = 0; i < length; i++){\n            abiParameters.push(parseAbiParameter(params[i], {\n                modifiers: eventModifiers,\n                structs,\n                type: \"event\"\n            }));\n        }\n        return {\n            name: match.name,\n            type: \"event\",\n            inputs: abiParameters\n        };\n    }\n    if (isErrorSignature(signature)) {\n        const match = execErrorSignature(signature);\n        if (!match) throw new BaseError(\"Invalid error signature.\", {\n            details: signature\n        });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for(let i = 0; i < length; i++){\n            abiParameters.push(parseAbiParameter(params[i], {\n                structs,\n                type: \"error\"\n            }));\n        }\n        return {\n            name: match.name,\n            type: \"error\",\n            inputs: abiParameters\n        };\n    }\n    if (isConstructorSignature(signature)) {\n        const match = execConstructorSignature(signature);\n        if (!match) throw new BaseError(\"Invalid constructor signature.\", {\n            details: signature\n        });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for(let i = 0; i < length; i++){\n            abiParameters.push(parseAbiParameter(params[i], {\n                structs,\n                type: \"constructor\"\n            }));\n        }\n        return {\n            type: \"constructor\",\n            stateMutability: match.stateMutability ?? \"nonpayable\",\n            inputs: abiParameters\n        };\n    }\n    if (isFallbackSignature(signature)) return {\n        type: \"fallback\"\n    };\n    if (isReceiveSignature(signature)) return {\n        type: \"receive\",\n        stateMutability: \"payable\"\n    };\n    throw new BaseError(\"Unknown signature.\", {\n        details: signature\n    });\n}\nvar abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n    const parameterCacheKey = getParameterCacheKey(param, options?.type);\n    if (parameterCache.has(parameterCacheKey)) return parameterCache.get(parameterCacheKey);\n    const isTuple = _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.isTupleRegex.test(param);\n    const match = (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match) throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param\n    });\n    if (match.name && isSolidityKeyword(match.name)) throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n            `\"${match.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`\n        ]\n    });\n    const name2 = match.name ? {\n        name: match.name\n    } : {};\n    const indexed = match.modifier === \"indexed\" ? {\n        indexed: true\n    } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = \"tuple\";\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for(let i = 0; i < length; i++){\n            components_.push(parseAbiParameter(params[i], {\n                structs\n            }));\n        }\n        components = {\n            components: components_\n        };\n    } else if (match.type in structs) {\n        type = \"tuple\";\n        components = {\n            components: structs[match.type]\n        };\n    } else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    } else {\n        type = match.type;\n        if (!(options?.type === \"struct\") && !isSolidityType(type)) throw new BaseError(\"Unknown type.\", {\n            metaMessages: [\n                `Type \"${type}\" is not a valid ABI type.`\n            ]\n        });\n    }\n    if (match.modifier) {\n        if (!options?.modifiers?.has?.(match.modifier)) throw new BaseError(\"Invalid ABI parameter.\", {\n            details: param,\n            metaMessages: [\n                `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`\n            ]\n        });\n        if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new BaseError(\"Invalid ABI parameter.\", {\n            details: param,\n            metaMessages: [\n                `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`,\n                `Data location can only be specified for array, struct, or mapping types, but \"${match.modifier}\" was given.`\n            ]\n        });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? \"\"}`,\n        ...name2,\n        ...indexed,\n        ...components\n    };\n    parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\nfunction splitParameters(params, result = [], current = \"\", depth = 0) {\n    if (params === \"\") {\n        if (current === \"\") return result;\n        if (depth !== 0) throw new BaseError(\"Unbalanced parentheses.\", {\n            metaMessages: [\n                `\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`\n            ],\n            details: `Depth \"${depth}\"`\n        });\n        return [\n            ...result,\n            current.trim()\n        ];\n    }\n    const length = params.length;\n    for(let i = 0; i < length; i++){\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch(char){\n            case \",\":\n                return depth === 0 ? splitParameters(tail, [\n                    ...result,\n                    current.trim()\n                ]) : splitParameters(tail, result, `${current}${char}`, depth);\n            case \"(\":\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case \")\":\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    return [];\n}\nfunction isSolidityType(type) {\n    return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.bytesRegex.test(type) || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n    return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.bytesRegex.test(name2) || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n    return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n    const shallowStructs = {};\n    const signaturesLength = signatures.length;\n    for(let i = 0; i < signaturesLength; i++){\n        const signature = signatures[i];\n        if (!isStructSignature(signature)) continue;\n        const match = execStructSignature(signature);\n        if (!match) throw new BaseError(\"Invalid struct signature.\", {\n            details: signature\n        });\n        const properties = match.properties.split(\";\");\n        const components = [];\n        const propertiesLength = properties.length;\n        for(let k = 0; k < propertiesLength; k++){\n            const property = properties[k];\n            const trimmed = property.trim();\n            if (!trimmed) continue;\n            const abiParameter = parseAbiParameter(trimmed, {\n                type: \"struct\"\n            });\n            components.push(abiParameter);\n        }\n        if (!components.length) throw new BaseError(\"Invalid struct signature.\", {\n            details: signature,\n            metaMessages: [\n                \"No properties exist.\"\n            ]\n        });\n        shallowStructs[match.name] = components;\n    }\n    const resolvedStructs = {};\n    const entries = Object.entries(shallowStructs);\n    const entriesLength = entries.length;\n    for(let i = 0; i < entriesLength; i++){\n        const [name2, parameters] = entries[i];\n        resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n    }\n    return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {\n    const components = [];\n    const length = abiParameters.length;\n    for(let i = 0; i < length; i++){\n        const abiParameter = abiParameters[i];\n        const isTuple = _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.isTupleRegex.test(abiParameter.type);\n        if (isTuple) components.push(abiParameter);\n        else {\n            const match = (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(typeWithoutTupleRegex, abiParameter.type);\n            if (!match?.type) throw new BaseError(\"Invalid ABI parameter.\", {\n                details: JSON.stringify(abiParameter, null, 2),\n                metaMessages: [\n                    \"ABI parameter type is invalid.\"\n                ]\n            });\n            const { array, type } = match;\n            if (type in structs) {\n                if (ancestors.has(type)) throw new BaseError(\"Circular reference detected.\", {\n                    metaMessages: [\n                        `Struct \"${type}\" is a circular reference.`\n                    ]\n                });\n                components.push({\n                    ...abiParameter,\n                    type: `tuple${array ?? \"\"}`,\n                    components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([\n                        ...ancestors,\n                        type\n                    ]))\n                });\n            } else {\n                if (isSolidityType(type)) components.push(abiParameter);\n                else throw new BaseError(\"Unknown type.\", {\n                    metaMessages: [\n                        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`\n                    ]\n                });\n            }\n        }\n    }\n    return components;\n}\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n    const structs = parseStructs(signatures);\n    const abi = [];\n    const length = signatures.length;\n    for(let i = 0; i < length; i++){\n        const signature = signatures[i];\n        if (isStructSignature(signature)) continue;\n        abi.push(parseSignature(signature, structs));\n    }\n    return abi;\n}\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === \"string\") abiItem = parseSignature(signature);\n    else {\n        const structs = parseStructs(signature);\n        const length = signature.length;\n        for(let i = 0; i < length; i++){\n            const signature_ = signature[i];\n            if (isStructSignature(signature_)) continue;\n            abiItem = parseSignature(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem) throw new BaseError(\"Failed to parse ABI item.\", {\n        details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n        docsPath: \"/api/human.html#parseabiitem-1\"\n    });\n    return abiItem;\n}\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n    let abiParameter;\n    if (typeof param === \"string\") abiParameter = parseAbiParameter(param, {\n        modifiers\n    });\n    else {\n        const structs = parseStructs(param);\n        const length = param.length;\n        for(let i = 0; i < length; i++){\n            const signature = param[i];\n            if (isStructSignature(signature)) continue;\n            abiParameter = parseAbiParameter(signature, {\n                modifiers,\n                structs\n            });\n            break;\n        }\n    }\n    if (!abiParameter) throw new BaseError(\"Failed to parse ABI parameter.\", {\n        details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n        docsPath: \"/api/human.html#parseabiparameter-1\"\n    });\n    return abiParameter;\n}\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n    const abiParameters = [];\n    if (typeof params === \"string\") {\n        const parameters = splitParameters(params);\n        const length = parameters.length;\n        for(let i = 0; i < length; i++){\n            abiParameters.push(parseAbiParameter(parameters[i], {\n                modifiers\n            }));\n        }\n    } else {\n        const structs = parseStructs(params);\n        const length = params.length;\n        for(let i = 0; i < length; i++){\n            const signature = params[i];\n            if (isStructSignature(signature)) continue;\n            const parameters = splitParameters(signature);\n            const length2 = parameters.length;\n            for(let k = 0; k < length2; k++){\n                abiParameters.push(parseAbiParameter(parameters[k], {\n                    modifiers,\n                    structs\n                }));\n            }\n        }\n    }\n    if (abiParameters.length === 0) throw new BaseError(\"Failed to parse ABI parameters.\", {\n        details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n        docsPath: \"/api/human.html#parseabiparameters-1\"\n    });\n    return abiParameters;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUs4QjtBQUdBO0FBRTlCLGVBQWU7QUFDZixJQUFJSyxPQUFPO0FBQ1gsSUFBSUMsVUFBVTtBQUVkLGdCQUFnQjtBQUNoQixJQUFJQyxZQUFZLGNBQWNDO0lBQzVCQyxZQUFZQyxZQUFZLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkMsTUFBTUMsVUFBVUQsS0FBS0UsS0FBSyxZQUFZTixZQUFZSSxLQUFLRSxLQUFLLENBQUNELE9BQU8sR0FBR0QsS0FBS0UsS0FBSyxFQUFFQyxVQUFVSCxLQUFLRSxLQUFLLENBQUNDLE9BQU8sR0FBR0gsS0FBS0MsT0FBTztRQUM5SCxNQUFNRyxXQUFXSixLQUFLRSxLQUFLLFlBQVlOLFlBQVlJLEtBQUtFLEtBQUssQ0FBQ0UsUUFBUSxJQUFJSixLQUFLSSxRQUFRLEdBQUdKLEtBQUtJLFFBQVE7UUFDdkcsTUFBTUQsVUFBVTtZQUNkSixnQkFBZ0I7WUFDaEI7ZUFDR0MsS0FBS0ssWUFBWSxHQUFHO21CQUFJTCxLQUFLSyxZQUFZO2dCQUFFO2FBQUcsR0FBRyxFQUFFO2VBQ25ERCxXQUFXO2dCQUFDLENBQUMseUJBQXlCLEVBQUVBLFNBQVMsQ0FBQzthQUFDLEdBQUcsRUFBRTtlQUN4REgsVUFBVTtnQkFBQyxDQUFDLFNBQVMsRUFBRUEsUUFBUSxDQUFDO2FBQUMsR0FBRyxFQUFFO1lBQ3pDLENBQUMsU0FBUyxFQUFFUCxLQUFLLENBQUMsRUFBRUMsUUFBUSxDQUFDO1NBQzlCLENBQUNXLElBQUksQ0FBQztRQUNQLEtBQUssQ0FBQ0g7UUFDTlYsa0VBQWFBLENBQUMsSUFBSSxFQUFFO1FBQ3BCQSxrRUFBYUEsQ0FBQyxJQUFJLEVBQUU7UUFDcEJBLGtFQUFhQSxDQUFDLElBQUksRUFBRTtRQUNwQkEsa0VBQWFBLENBQUMsSUFBSSxFQUFFO1FBQ3BCQSxrRUFBYUEsQ0FBQyxJQUFJLEVBQUUsUUFB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QUFNWixhQUFhRCxnQkFBZ0JhO1FBQ25DLE1BQU1ULFNBQVNILFdBQVdHLE1BQU07UUFDaEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELFFBQVFDLElBQUs7WUFDL0JTLGNBQWNSLElBQUksQ0FBQ0Msa0JBQWtCTixVQUFVLENBQUNJLEVBQUUsRUFBRTtnQkFBRW5CO1lBQVU7UUFDbEU7SUFDRixPQUFPO1FBQ0wsTUFBTVcsVUFBVTZDLGFBQWE3QjtRQUM3QixNQUFNVCxTQUFTUyxPQUFPVCxNQUFNO1FBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxRQUFRQyxJQUFLO1lBQy9CLE1BQU10QyxZQUFZOEMsTUFBTSxDQUFDUixFQUFFO1lBQzNCLElBQUk1QixrQkFBa0JWLFlBQ3BCO1lBQ0YsTUFBTWtDLGFBQWFELGdCQUFnQmpDO1lBQ25DLE1BQU1xRyxVQUFVbkUsV0FBV0csTUFBTTtZQUNqQyxJQUFLLElBQUk2QyxJQUFJLEdBQUdBLElBQUltQixTQUFTbkIsSUFBSztnQkFDaENuQyxjQUFjUixJQUFJLENBQ2hCQyxrQkFBa0JOLFVBQVUsQ0FBQ2dELEVBQUUsRUFBRTtvQkFBRS9EO29CQUFXVztnQkFBUTtZQUUxRDtRQUNGO0lBQ0Y7SUFDQSxJQUFJaUIsY0FBY1YsTUFBTSxLQUFLLEdBQzNCLE1BQU0sSUFBSXBELFVBQVUsbUNBQW1DO1FBQ3JESyxTQUFTLENBQUMsbUJBQW1CLEVBQUVzRyxLQUFLQyxTQUFTLENBQUMvQyxRQUFRLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDakVyRCxVQUFVO0lBQ1o7SUFDRixPQUFPc0Q7QUFDVDtBQVFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2luZGV4Lm1qcz8zOTFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGJ5dGVzUmVnZXgsXG4gIGV4ZWNUeXBlZCxcbiAgaW50ZWdlclJlZ2V4LFxuICBpc1R1cGxlUmVnZXhcbn0gZnJvbSBcIi4vY2h1bmstV1A3S0RWNDcubWpzXCI7XG5pbXBvcnQge1xuICBfX3B1YmxpY0ZpZWxkXG59IGZyb20gXCIuL2NodW5rLU5IQUJVNzUyLm1qc1wiO1xuXG4vLyBwYWNrYWdlLmpzb25cbnZhciBuYW1lID0gXCJhYml0eXBlXCI7XG52YXIgdmVyc2lvbiA9IFwiMC43LjFcIjtcblxuLy8gc3JjL2Vycm9ycy50c1xudmFyIEJhc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGRldGFpbHMgPSBhcmdzLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yID8gYXJncy5jYXVzZS5kZXRhaWxzIDogYXJncy5jYXVzZT8ubWVzc2FnZSA/IGFyZ3MuY2F1c2UubWVzc2FnZSA6IGFyZ3MuZGV0YWlscztcbiAgICBjb25zdCBkb2NzUGF0aCA9IGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IgPyBhcmdzLmNhdXNlLmRvY3NQYXRoIHx8IGFyZ3MuZG9jc1BhdGggOiBhcmdzLmRvY3NQYXRoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICBzaG9ydE1lc3NhZ2UgfHwgXCJBbiBlcnJvciBvY2N1cnJlZC5cIixcbiAgICAgIFwiXCIsXG4gICAgICAuLi5hcmdzLm1ldGFNZXNzYWdlcyA/IFsuLi5hcmdzLm1ldGFNZXNzYWdlcywgXCJcIl0gOiBbXSxcbiAgICAgIC4uLmRvY3NQYXRoID8gW2BEb2NzOiBodHRwczovL2FiaXR5cGUuZGV2JHtkb2NzUGF0aH1gXSA6IFtdLFxuICAgICAgLi4uZGV0YWlscyA/IFtgRGV0YWlsczogJHtkZXRhaWxzfWBdIDogW10sXG4gICAgICBgVmVyc2lvbjogJHtuYW1lfUAke3ZlcnNpb259YFxuICAgIF0uam9pbihcIlxcblwiKTtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGV0YWlsc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9jc1BhdGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1ldGFNZXNzYWdlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2hvcnRNZXNzYWdlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiQWJpVHlwZUVycm9yXCIpO1xuICAgIGlmIChhcmdzLmNhdXNlKVxuICAgICAgdGhpcy5jYXVzZSA9IGFyZ3MuY2F1c2U7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgdGhpcy5tZXRhTWVzc2FnZXMgPSBhcmdzLm1ldGFNZXNzYWdlcztcbiAgICB0aGlzLnNob3J0TWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcbiAgfVxufTtcblxuLy8gc3JjL25hcnJvdy50c1xuZnVuY3Rpb24gbmFycm93KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvc2lnbmF0dXJlcy50c1xudmFyIGVycm9yU2lnbmF0dXJlUmVnZXggPSAvXmVycm9yICg/PG5hbWU+W2EtekEtWjAtOV9dKylcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXCkkLztcbmZ1bmN0aW9uIGlzRXJyb3JTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBlcnJvclNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmZ1bmN0aW9uIGV4ZWNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGV4ZWNUeXBlZChcbiAgICBlcnJvclNpZ25hdHVyZVJlZ2V4LFxuICAgIHNpZ25hdHVyZVxuICApO1xufVxudmFyIGV2ZW50U2lnbmF0dXJlUmVnZXggPSAvXmV2ZW50ICg/PG5hbWU+W2EtekEtWjAtOV9dKylcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXCkkLztcbmZ1bmN0aW9uIGlzRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBldmVudFNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmZ1bmN0aW9uIGV4ZWNFdmVudFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGV4ZWNUeXBlZChcbiAgICBldmVudFNpZ25hdHVyZVJlZ2V4LFxuICAgIHNpZ25hdHVyZVxuICApO1xufVxudmFyIGZ1bmN0aW9uU2lnbmF0dXJlUmVnZXggPSAvXmZ1bmN0aW9uICg/PG5hbWU+W2EtekEtWjAtOV9dKylcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXCkoPzogKD88c2NvcGU+ZXh0ZXJuYWx8cHVibGljezF9KSk/KD86ICg/PHN0YXRlTXV0YWJpbGl0eT5wdXJlfHZpZXd8bm9ucGF5YWJsZXxwYXlhYmxlezF9KSk/KD86IHJldHVybnMgXFwoKD88cmV0dXJucz4uKj8pXFwpKT8kLztcbmZ1bmN0aW9uIGlzRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBmdW5jdGlvblNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmZ1bmN0aW9uIGV4ZWNGdW5jdGlvblNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGV4ZWNUeXBlZChmdW5jdGlvblNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xufVxudmFyIHN0cnVjdFNpZ25hdHVyZVJlZ2V4ID0gL15zdHJ1Y3QgKD88bmFtZT5bYS16QS1aMC05X10rKSBcXHsoPzxwcm9wZXJ0aWVzPi4qPylcXH0kLztcbmZ1bmN0aW9uIGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gc3RydWN0U2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gZXhlY1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGV4ZWNUeXBlZChcbiAgICBzdHJ1Y3RTaWduYXR1cmVSZWdleCxcbiAgICBzaWduYXR1cmVcbiAgKTtcbn1cbnZhciBjb25zdHJ1Y3RvclNpZ25hdHVyZVJlZ2V4ID0gL15jb25zdHJ1Y3RvclxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSg/Olxccyg/PHN0YXRlTXV0YWJpbGl0eT5wYXlhYmxlezF9KSk/JC87XG5mdW5jdGlvbiBpc0NvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gY29uc3RydWN0b3JTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XG59XG5mdW5jdGlvbiBleGVjQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBleGVjVHlwZWQoY29uc3RydWN0b3JTaWduYXR1cmVSZWdleCwgc2lnbmF0dXJlKTtcbn1cbnZhciBmYWxsYmFja1NpZ25hdHVyZVJlZ2V4ID0gL15mYWxsYmFja1xcKFxcKSQvO1xuZnVuY3Rpb24gaXNGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGZhbGxiYWNrU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxudmFyIHJlY2VpdmVTaWduYXR1cmVSZWdleCA9IC9ecmVjZWl2ZVxcKFxcKSBleHRlcm5hbCBwYXlhYmxlJC87XG5mdW5jdGlvbiBpc1JlY2VpdmVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiByZWNlaXZlU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxudmFyIG1vZGlmaWVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJtZW1vcnlcIixcbiAgXCJpbmRleGVkXCIsXG4gIFwic3RvcmFnZVwiLFxuICBcImNhbGxkYXRhXCJcbl0pO1xudmFyIGV2ZW50TW9kaWZpZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaW5kZXhlZFwiXSk7XG52YXIgZnVuY3Rpb25Nb2RpZmllcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY2FsbGRhdGFcIixcbiAgXCJtZW1vcnlcIixcbiAgXCJzdG9yYWdlXCJcbl0pO1xuXG4vLyBzcmMvaHVtYW4tcmVhZGFibGUvcnVudGltZS9jYWNoZS50c1xuZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQ2FjaGVLZXkocGFyYW0sIHR5cGUpIHtcbiAgaWYgKHR5cGUpXG4gICAgcmV0dXJuIGAke3R5cGV9OiR7cGFyYW19YDtcbiAgcmV0dXJuIHBhcmFtO1xufVxudmFyIHBhcmFtZXRlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAvLyBVbm5hbWVkXG4gIFtcImFkZHJlc3NcIiwgeyB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgW1wiYm9vbFwiLCB7IHR5cGU6IFwiYm9vbFwiIH1dLFxuICBbXCJieXRlc1wiLCB7IHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgW1wiYnl0ZXMzMlwiLCB7IHR5cGU6IFwiYnl0ZXMzMlwiIH1dLFxuICBbXCJpbnRcIiwgeyB0eXBlOiBcImludDI1NlwiIH1dLFxuICBbXCJpbnQyNTZcIiwgeyB0eXBlOiBcImludDI1NlwiIH1dLFxuICBbXCJzdHJpbmdcIiwgeyB0eXBlOiBcInN0cmluZ1wiIH1dLFxuICBbXCJ1aW50XCIsIHsgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gIFtcInVpbnQ4XCIsIHsgdHlwZTogXCJ1aW50OFwiIH1dLFxuICBbXCJ1aW50MTZcIiwgeyB0eXBlOiBcInVpbnQxNlwiIH1dLFxuICBbXCJ1aW50MjRcIiwgeyB0eXBlOiBcInVpbnQyNFwiIH1dLFxuICBbXCJ1aW50MzJcIiwgeyB0eXBlOiBcInVpbnQzMlwiIH1dLFxuICBbXCJ1aW50NjRcIiwgeyB0eXBlOiBcInVpbnQ2NFwiIH1dLFxuICBbXCJ1aW50OTZcIiwgeyB0eXBlOiBcInVpbnQ5NlwiIH1dLFxuICBbXCJ1aW50MTEyXCIsIHsgdHlwZTogXCJ1aW50MTEyXCIgfV0sXG4gIFtcInVpbnQxNjBcIiwgeyB0eXBlOiBcInVpbnQxNjBcIiB9XSxcbiAgW1widWludDE5MlwiLCB7IHR5cGU6IFwidWludDE5MlwiIH1dLFxuICBbXCJ1aW50MjU2XCIsIHsgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gIC8vIE5hbWVkXG4gIFtcImFkZHJlc3Mgb3duZXJcIiwgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJvd25lclwiIH1dLFxuICBbXCJhZGRyZXNzIHRvXCIsIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9cIiB9XSxcbiAgW1wiYm9vbCBhcHByb3ZlZFwiLCB7IHR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcImFwcHJvdmVkXCIgfV0sXG4gIFtcImJ5dGVzIF9kYXRhXCIsIHsgdHlwZTogXCJieXRlc1wiLCBuYW1lOiBcIl9kYXRhXCIgfV0sXG4gIFtcImJ5dGVzIGRhdGFcIiwgeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiZGF0YVwiIH1dLFxuICBbXCJieXRlcyBzaWduYXR1cmVcIiwgeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwic2lnbmF0dXJlXCIgfV0sXG4gIFtcImJ5dGVzMzIgaGFzaFwiLCB7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcImhhc2hcIiB9XSxcbiAgW1wiYnl0ZXMzMiByXCIsIHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiclwiIH1dLFxuICBbXCJieXRlczMyIHJvb3RcIiwgeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJyb290XCIgfV0sXG4gIFtcImJ5dGVzMzIgc1wiLCB7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInNcIiB9XSxcbiAgW1wic3RyaW5nIG5hbWVcIiwgeyB0eXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIm5hbWVcIiB9XSxcbiAgW1wic3RyaW5nIHN5bWJvbFwiLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwic3ltYm9sXCIgfV0sXG4gIFtcInN0cmluZyB0b2tlblVSSVwiLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwidG9rZW5VUklcIiB9XSxcbiAgW1widWludCB0b2tlbklkXCIsIHsgdHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG9rZW5JZFwiIH1dLFxuICBbXCJ1aW50OCB2XCIsIHsgdHlwZTogXCJ1aW50OFwiLCBuYW1lOiBcInZcIiB9XSxcbiAgW1widWludDI1NiBiYWxhbmNlXCIsIHsgdHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiYmFsYW5jZVwiIH1dLFxuICBbXCJ1aW50MjU2IHRva2VuSWRcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ0b2tlbklkXCIgfV0sXG4gIFtcInVpbnQyNTYgdmFsdWVcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiIH1dLFxuICAvLyBJbmRleGVkXG4gIFtcbiAgICBcImV2ZW50OmFkZHJlc3MgaW5kZXhlZCBmcm9tXCIsXG4gICAgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJmcm9tXCIsIGluZGV4ZWQ6IHRydWUgfVxuICBdLFxuICBbXCJldmVudDphZGRyZXNzIGluZGV4ZWQgdG9cIiwgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCBpbmRleGVkOiB0cnVlIH1dLFxuICBbXG4gICAgXCJldmVudDp1aW50IGluZGV4ZWQgdG9rZW5JZFwiLFxuICAgIHsgdHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG9rZW5JZFwiLCBpbmRleGVkOiB0cnVlIH1cbiAgXSxcbiAgW1xuICAgIFwiZXZlbnQ6dWludDI1NiBpbmRleGVkIHRva2VuSWRcIixcbiAgICB7IHR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInRva2VuSWRcIiwgaW5kZXhlZDogdHJ1ZSB9XG4gIF1cbl0pO1xuXG4vLyBzcmMvaHVtYW4tcmVhZGFibGUvcnVudGltZS91dGlscy50c1xuZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzID0ge30pIHtcbiAgaWYgKGlzRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKSkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhlY0Z1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJJbnZhbGlkIGZ1bmN0aW9uIHNpZ25hdHVyZS5cIiwge1xuICAgICAgICBkZXRhaWxzOiBzaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIGNvbnN0IGlucHV0UGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGlucHV0cyA9IFtdO1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXRQYXJhbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRMZW5ndGg7IGkrKykge1xuICAgICAgaW5wdXRzLnB1c2goXG4gICAgICAgIHBhcnNlQWJpUGFyYW1ldGVyKGlucHV0UGFyYW1zW2ldLCB7XG4gICAgICAgICAgbW9kaWZpZXJzOiBmdW5jdGlvbk1vZGlmaWVycyxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAgIGlmIChtYXRjaC5yZXR1cm5zKSB7XG4gICAgICBjb25zdCBvdXRwdXRQYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucmV0dXJucyk7XG4gICAgICBjb25zdCBvdXRwdXRMZW5ndGggPSBvdXRwdXRQYXJhbXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRwdXRzLnB1c2goXG4gICAgICAgICAgcGFyc2VBYmlQYXJhbWV0ZXIob3V0cHV0UGFyYW1zW2ldLCB7XG4gICAgICAgICAgICBtb2RpZmllcnM6IGZ1bmN0aW9uTW9kaWZpZXJzLFxuICAgICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBtYXRjaC5uYW1lLFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBtYXRjaC5zdGF0ZU11dGFiaWxpdHkgPz8gXCJub25wYXlhYmxlXCIsXG4gICAgICBpbnB1dHMsXG4gICAgICBvdXRwdXRzXG4gICAgfTtcbiAgfVxuICBpZiAoaXNFdmVudFNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgZXZlbnQgc2lnbmF0dXJlLlwiLCB7XG4gICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChcbiAgICAgICAgcGFyc2VBYmlQYXJhbWV0ZXIocGFyYW1zW2ldLCB7XG4gICAgICAgICAgbW9kaWZpZXJzOiBldmVudE1vZGlmaWVycyxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIlxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbmFtZTogbWF0Y2gubmFtZSwgdHlwZTogXCJldmVudFwiLCBpbnB1dHM6IGFiaVBhcmFtZXRlcnMgfTtcbiAgfVxuICBpZiAoaXNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjRXJyb3JTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgZXJyb3Igc2lnbmF0dXJlLlwiLCB7XG4gICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChcbiAgICAgICAgcGFyc2VBYmlQYXJhbWV0ZXIocGFyYW1zW2ldLCB7IHN0cnVjdHMsIHR5cGU6IFwiZXJyb3JcIiB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbmFtZTogbWF0Y2gubmFtZSwgdHlwZTogXCJlcnJvclwiLCBpbnB1dHM6IGFiaVBhcmFtZXRlcnMgfTtcbiAgfVxuICBpZiAoaXNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgY29uc3RydWN0b3Igc2lnbmF0dXJlLlwiLCB7XG4gICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChcbiAgICAgICAgcGFyc2VBYmlQYXJhbWV0ZXIocGFyYW1zW2ldLCB7IHN0cnVjdHMsIHR5cGU6IFwiY29uc3RydWN0b3JcIiB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogbWF0Y2guc3RhdGVNdXRhYmlsaXR5ID8/IFwibm9ucGF5YWJsZVwiLFxuICAgICAgaW5wdXRzOiBhYmlQYXJhbWV0ZXJzXG4gICAgfTtcbiAgfVxuICBpZiAoaXNGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgIHJldHVybiB7IHR5cGU6IFwiZmFsbGJhY2tcIiB9O1xuICBpZiAoaXNSZWNlaXZlU2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmVjZWl2ZVwiLFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIlxuICAgIH07XG4gIHRocm93IG5ldyBCYXNlRXJyb3IoXCJVbmtub3duIHNpZ25hdHVyZS5cIiwge1xuICAgIGRldGFpbHM6IHNpZ25hdHVyZVxuICB9KTtcbn1cbnZhciBhYmlQYXJhbWV0ZXJXaXRob3V0VHVwbGVSZWdleCA9IC9eKD88dHlwZT5bYS16QS1aMC05X10rPykoPzxhcnJheT4oPzpcXFtcXGQqP1xcXSkrPyk/KD86XFxzKD88bW9kaWZpZXI+Y2FsbGRhdGF8aW5kZXhlZHxtZW1vcnl8c3RvcmFnZXsxfSkpPyg/Olxccyg/PG5hbWU+W2EtekEtWjAtOV9dKykpPyQvO1xudmFyIGFiaVBhcmFtZXRlcldpdGhUdXBsZVJlZ2V4ID0gL15cXCgoPzx0eXBlPi4rPylcXCkoPzxhcnJheT4oPzpcXFtcXGQqP1xcXSkrPyk/KD86XFxzKD88bW9kaWZpZXI+Y2FsbGRhdGF8aW5kZXhlZHxtZW1vcnl8c3RvcmFnZXsxfSkpPyg/Olxccyg/PG5hbWU+W2EtekEtWjAtOV9dKykpPyQvO1xudmFyIGR5bmFtaWNJbnRlZ2VyUmVnZXggPSAvXnU/aW50JC87XG5mdW5jdGlvbiBwYXJzZUFiaVBhcmFtZXRlcihwYXJhbSwgb3B0aW9ucykge1xuICBjb25zdCBwYXJhbWV0ZXJDYWNoZUtleSA9IGdldFBhcmFtZXRlckNhY2hlS2V5KHBhcmFtLCBvcHRpb25zPy50eXBlKTtcbiAgaWYgKHBhcmFtZXRlckNhY2hlLmhhcyhwYXJhbWV0ZXJDYWNoZUtleSkpXG4gICAgcmV0dXJuIHBhcmFtZXRlckNhY2hlLmdldChwYXJhbWV0ZXJDYWNoZUtleSk7XG4gIGNvbnN0IGlzVHVwbGUgPSBpc1R1cGxlUmVnZXgudGVzdChwYXJhbSk7XG4gIGNvbnN0IG1hdGNoID0gZXhlY1R5cGVkKFxuICAgIGlzVHVwbGUgPyBhYmlQYXJhbWV0ZXJXaXRoVHVwbGVSZWdleCA6IGFiaVBhcmFtZXRlcldpdGhvdXRUdXBsZVJlZ2V4LFxuICAgIHBhcmFtXG4gICk7XG4gIGlmICghbWF0Y2gpXG4gICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgQUJJIHBhcmFtZXRlci5cIiwge1xuICAgICAgZGV0YWlsczogcGFyYW1cbiAgICB9KTtcbiAgaWYgKG1hdGNoLm5hbWUgJiYgaXNTb2xpZGl0eUtleXdvcmQobWF0Y2gubmFtZSkpXG4gICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgQUJJIHBhcmFtZXRlci5cIiwge1xuICAgICAgZGV0YWlsczogcGFyYW0sXG4gICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgYFwiJHttYXRjaC5uYW1lfVwiIGlzIGEgcHJvdGVjdGVkIFNvbGlkaXR5IGtleXdvcmQuIE1vcmUgaW5mbzogaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2NoZWF0c2hlZXQuaHRtbGBcbiAgICAgIF1cbiAgICB9KTtcbiAgY29uc3QgbmFtZTIgPSBtYXRjaC5uYW1lID8geyBuYW1lOiBtYXRjaC5uYW1lIH0gOiB7fTtcbiAgY29uc3QgaW5kZXhlZCA9IG1hdGNoLm1vZGlmaWVyID09PSBcImluZGV4ZWRcIiA/IHsgaW5kZXhlZDogdHJ1ZSB9IDoge307XG4gIGNvbnN0IHN0cnVjdHMgPSBvcHRpb25zPy5zdHJ1Y3RzID8/IHt9O1xuICBsZXQgdHlwZTtcbiAgbGV0IGNvbXBvbmVudHMgPSB7fTtcbiAgaWYgKGlzVHVwbGUpIHtcbiAgICB0eXBlID0gXCJ0dXBsZVwiO1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC50eXBlKTtcbiAgICBjb25zdCBjb21wb25lbnRzXyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29tcG9uZW50c18ucHVzaChwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHsgc3RydWN0cyB9KSk7XG4gICAgfVxuICAgIGNvbXBvbmVudHMgPSB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHNfIH07XG4gIH0gZWxzZSBpZiAobWF0Y2gudHlwZSBpbiBzdHJ1Y3RzKSB7XG4gICAgdHlwZSA9IFwidHVwbGVcIjtcbiAgICBjb21wb25lbnRzID0geyBjb21wb25lbnRzOiBzdHJ1Y3RzW21hdGNoLnR5cGVdIH07XG4gIH0gZWxzZSBpZiAoZHluYW1pY0ludGVnZXJSZWdleC50ZXN0KG1hdGNoLnR5cGUpKSB7XG4gICAgdHlwZSA9IGAke21hdGNoLnR5cGV9MjU2YDtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gbWF0Y2gudHlwZTtcbiAgICBpZiAoIShvcHRpb25zPy50eXBlID09PSBcInN0cnVjdFwiKSAmJiAhaXNTb2xpZGl0eVR5cGUodHlwZSkpXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiVW5rbm93biB0eXBlLlwiLCB7XG4gICAgICAgIG1ldGFNZXNzYWdlczogW2BUeXBlIFwiJHt0eXBlfVwiIGlzIG5vdCBhIHZhbGlkIEFCSSB0eXBlLmBdXG4gICAgICB9KTtcbiAgfVxuICBpZiAobWF0Y2gubW9kaWZpZXIpIHtcbiAgICBpZiAoIW9wdGlvbnM/Lm1vZGlmaWVycz8uaGFzPy4obWF0Y2gubW9kaWZpZXIpKVxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgQUJJIHBhcmFtZXRlci5cIiwge1xuICAgICAgICBkZXRhaWxzOiBwYXJhbSxcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgYE1vZGlmaWVyIFwiJHttYXRjaC5tb2RpZmllcn1cIiBub3QgYWxsb3dlZCR7b3B0aW9ucz8udHlwZSA/IGAgaW4gXCIke29wdGlvbnMudHlwZX1cIiB0eXBlYCA6IFwiXCJ9LmBcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgaWYgKGZ1bmN0aW9uTW9kaWZpZXJzLmhhcyhtYXRjaC5tb2RpZmllcikgJiYgIWlzVmFsaWREYXRhTG9jYXRpb24odHlwZSwgISFtYXRjaC5hcnJheSkpXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBBQkkgcGFyYW1ldGVyLlwiLCB7XG4gICAgICAgIGRldGFpbHM6IHBhcmFtLFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICBgTW9kaWZpZXIgXCIke21hdGNoLm1vZGlmaWVyfVwiIG5vdCBhbGxvd2VkJHtvcHRpb25zPy50eXBlID8gYCBpbiBcIiR7b3B0aW9ucy50eXBlfVwiIHR5cGVgIDogXCJcIn0uYCxcbiAgICAgICAgICBgRGF0YSBsb2NhdGlvbiBjYW4gb25seSBiZSBzcGVjaWZpZWQgZm9yIGFycmF5LCBzdHJ1Y3QsIG9yIG1hcHBpbmcgdHlwZXMsIGJ1dCBcIiR7bWF0Y2gubW9kaWZpZXJ9XCIgd2FzIGdpdmVuLmBcbiAgICAgICAgXVxuICAgICAgfSk7XG4gIH1cbiAgY29uc3QgYWJpUGFyYW1ldGVyID0ge1xuICAgIHR5cGU6IGAke3R5cGV9JHttYXRjaC5hcnJheSA/PyBcIlwifWAsXG4gICAgLi4ubmFtZTIsXG4gICAgLi4uaW5kZXhlZCxcbiAgICAuLi5jb21wb25lbnRzXG4gIH07XG4gIHBhcmFtZXRlckNhY2hlLnNldChwYXJhbWV0ZXJDYWNoZUtleSwgYWJpUGFyYW1ldGVyKTtcbiAgcmV0dXJuIGFiaVBhcmFtZXRlcjtcbn1cbmZ1bmN0aW9uIHNwbGl0UGFyYW1ldGVycyhwYXJhbXMsIHJlc3VsdCA9IFtdLCBjdXJyZW50ID0gXCJcIiwgZGVwdGggPSAwKSB7XG4gIGlmIChwYXJhbXMgPT09IFwiXCIpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gXCJcIilcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGRlcHRoICE9PSAwKVxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIlVuYmFsYW5jZWQgcGFyZW50aGVzZXMuXCIsIHtcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgYFwiJHtjdXJyZW50LnRyaW0oKX1cIiBoYXMgdG9vIG1hbnkgJHtkZXB0aCA+IDAgPyBcIm9wZW5pbmdcIiA6IFwiY2xvc2luZ1wifSBwYXJlbnRoZXNlcy5gXG4gICAgICAgIF0sXG4gICAgICAgIGRldGFpbHM6IGBEZXB0aCBcIiR7ZGVwdGh9XCJgXG4gICAgICB9KTtcbiAgICByZXR1cm4gWy4uLnJlc3VsdCwgY3VycmVudC50cmltKCldO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gcGFyYW1zW2ldO1xuICAgIGNvbnN0IHRhaWwgPSBwYXJhbXMuc2xpY2UoaSArIDEpO1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgcmV0dXJuIGRlcHRoID09PSAwID8gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIFsuLi5yZXN1bHQsIGN1cnJlbnQudHJpbSgpXSkgOiBzcGxpdFBhcmFtZXRlcnModGFpbCwgcmVzdWx0LCBgJHtjdXJyZW50fSR7Y2hhcn1gLCBkZXB0aCk7XG4gICAgICBjYXNlIFwiKFwiOlxuICAgICAgICByZXR1cm4gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGggKyAxKTtcbiAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgIHJldHVybiBzcGxpdFBhcmFtZXRlcnModGFpbCwgcmVzdWx0LCBgJHtjdXJyZW50fSR7Y2hhcn1gLCBkZXB0aCAtIDEpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHNwbGl0UGFyYW1ldGVycyh0YWlsLCByZXN1bHQsIGAke2N1cnJlbnR9JHtjaGFyfWAsIGRlcHRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gaXNTb2xpZGl0eVR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSA9PT0gXCJhZGRyZXNzXCIgfHwgdHlwZSA9PT0gXCJib29sXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgYnl0ZXNSZWdleC50ZXN0KHR5cGUpIHx8IGludGVnZXJSZWdleC50ZXN0KHR5cGUpO1xufVxudmFyIHByb3RlY3RlZEtleXdvcmRzUmVnZXggPSAvXig/OmFmdGVyfGFsaWFzfGFub255bW91c3xhcHBseXxhdXRvfGJ5dGV8Y2FsbGRhdGF8Y2FzZXxjYXRjaHxjb25zdGFudHxjb3B5b2Z8ZGVmYXVsdHxkZWZpbmVkfGVycm9yfGV2ZW50fGV4dGVybmFsfGZhbHNlfGZpbmFsfGZ1bmN0aW9ufGltbXV0YWJsZXxpbXBsZW1lbnRzfGlufGluZGV4ZWR8aW5saW5lfGludGVybmFsfGxldHxtYXBwaW5nfG1hdGNofG1lbW9yeXxtdXRhYmxlfG51bGx8b2Z8b3ZlcnJpZGV8cGFydGlhbHxwcml2YXRlfHByb21pc2V8cHVibGljfHB1cmV8cmVmZXJlbmNlfHJlbG9jYXRhYmxlfHJldHVybnxyZXR1cm5zfHNpemVvZnxzdGF0aWN8c3RvcmFnZXxzdHJ1Y3R8c3VwZXJ8c3VwcG9ydHN8c3dpdGNofHRoaXN8dHJ1ZXx0cnl8dHlwZWRlZnx0eXBlb2Z8dmFyfHZpZXd8dmlydHVhbCkkLztcbmZ1bmN0aW9uIGlzU29saWRpdHlLZXl3b3JkKG5hbWUyKSB7XG4gIHJldHVybiBuYW1lMiA9PT0gXCJhZGRyZXNzXCIgfHwgbmFtZTIgPT09IFwiYm9vbFwiIHx8IG5hbWUyID09PSBcImZ1bmN0aW9uXCIgfHwgbmFtZTIgPT09IFwic3RyaW5nXCIgfHwgbmFtZTIgPT09IFwidHVwbGVcIiB8fCBieXRlc1JlZ2V4LnRlc3QobmFtZTIpIHx8IGludGVnZXJSZWdleC50ZXN0KG5hbWUyKSB8fCBwcm90ZWN0ZWRLZXl3b3Jkc1JlZ2V4LnRlc3QobmFtZTIpO1xufVxuZnVuY3Rpb24gaXNWYWxpZERhdGFMb2NhdGlvbih0eXBlLCBpc0FycmF5KSB7XG4gIHJldHVybiBpc0FycmF5IHx8IHR5cGUgPT09IFwiYnl0ZXNcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwidHVwbGVcIjtcbn1cblxuLy8gc3JjL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvc3RydWN0cy50c1xuZnVuY3Rpb24gcGFyc2VTdHJ1Y3RzKHNpZ25hdHVyZXMpIHtcbiAgY29uc3Qgc2hhbGxvd1N0cnVjdHMgPSB7fTtcbiAgY29uc3Qgc2lnbmF0dXJlc0xlbmd0aCA9IHNpZ25hdHVyZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25hdHVyZXNbaV07XG4gICAgaWYgKCFpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJJbnZhbGlkIHN0cnVjdCBzaWduYXR1cmUuXCIsIHtcbiAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWF0Y2gucHJvcGVydGllcy5zcGxpdChcIjtcIik7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgIGNvbnN0IHByb3BlcnRpZXNMZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IHByb3BlcnRpZXNMZW5ndGg7IGsrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2tdO1xuICAgICAgY29uc3QgdHJpbW1lZCA9IHByb3BlcnR5LnRyaW0oKTtcbiAgICAgIGlmICghdHJpbW1lZClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBhYmlQYXJhbWV0ZXIgPSBwYXJzZUFiaVBhcmFtZXRlcih0cmltbWVkLCB7XG4gICAgICAgIHR5cGU6IFwic3RydWN0XCJcbiAgICAgIH0pO1xuICAgICAgY29tcG9uZW50cy5wdXNoKGFiaVBhcmFtZXRlcik7XG4gICAgfVxuICAgIGlmICghY29tcG9uZW50cy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBzdHJ1Y3Qgc2lnbmF0dXJlLlwiLCB7XG4gICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZSxcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXCJObyBwcm9wZXJ0aWVzIGV4aXN0LlwiXVxuICAgICAgfSk7XG4gICAgc2hhbGxvd1N0cnVjdHNbbWF0Y2gubmFtZV0gPSBjb21wb25lbnRzO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkU3RydWN0cyA9IHt9O1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc2hhbGxvd1N0cnVjdHMpO1xuICBjb25zdCBlbnRyaWVzTGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW25hbWUyLCBwYXJhbWV0ZXJzXSA9IGVudHJpZXNbaV07XG4gICAgcmVzb2x2ZWRTdHJ1Y3RzW25hbWUyXSA9IHJlc29sdmVTdHJ1Y3RzKHBhcmFtZXRlcnMsIHNoYWxsb3dTdHJ1Y3RzKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRTdHJ1Y3RzO1xufVxudmFyIHR5cGVXaXRob3V0VHVwbGVSZWdleCA9IC9eKD88dHlwZT5bYS16QS1aMC05X10rPykoPzxhcnJheT4oPzpcXFtcXGQqP1xcXSkrPyk/JC87XG5mdW5jdGlvbiByZXNvbHZlU3RydWN0cyhhYmlQYXJhbWV0ZXJzLCBzdHJ1Y3RzLCBhbmNlc3RvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgY29uc3QgbGVuZ3RoID0gYWJpUGFyYW1ldGVycy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXIgPSBhYmlQYXJhbWV0ZXJzW2ldO1xuICAgIGNvbnN0IGlzVHVwbGUgPSBpc1R1cGxlUmVnZXgudGVzdChhYmlQYXJhbWV0ZXIudHlwZSk7XG4gICAgaWYgKGlzVHVwbGUpXG4gICAgICBjb21wb25lbnRzLnB1c2goYWJpUGFyYW1ldGVyKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gZXhlY1R5cGVkKFxuICAgICAgICB0eXBlV2l0aG91dFR1cGxlUmVnZXgsXG4gICAgICAgIGFiaVBhcmFtZXRlci50eXBlXG4gICAgICApO1xuICAgICAgaWYgKCFtYXRjaD8udHlwZSlcbiAgICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgQUJJIHBhcmFtZXRlci5cIiwge1xuICAgICAgICAgIGRldGFpbHM6IEpTT04uc3RyaW5naWZ5KGFiaVBhcmFtZXRlciwgbnVsbCwgMiksXG4gICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXCJBQkkgcGFyYW1ldGVyIHR5cGUgaXMgaW52YWxpZC5cIl1cbiAgICAgICAgfSk7XG4gICAgICBjb25zdCB7IGFycmF5LCB0eXBlIH0gPSBtYXRjaDtcbiAgICAgIGlmICh0eXBlIGluIHN0cnVjdHMpIHtcbiAgICAgICAgaWYgKGFuY2VzdG9ycy5oYXModHlwZSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZC5cIiwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbYFN0cnVjdCBcIiR7dHlwZX1cIiBpcyBhIGNpcmN1bGFyIHJlZmVyZW5jZS5gXVxuICAgICAgICAgIH0pO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgIC4uLmFiaVBhcmFtZXRlcixcbiAgICAgICAgICB0eXBlOiBgdHVwbGUke2FycmF5ID8/IFwiXCJ9YCxcbiAgICAgICAgICBjb21wb25lbnRzOiByZXNvbHZlU3RydWN0cyhcbiAgICAgICAgICAgIHN0cnVjdHNbdHlwZV0gPz8gW10sXG4gICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmFuY2VzdG9ycywgdHlwZV0pXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1NvbGlkaXR5VHlwZSh0eXBlKSlcbiAgICAgICAgICBjb21wb25lbnRzLnB1c2goYWJpUGFyYW1ldGVyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJVbmtub3duIHR5cGUuXCIsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICBgVHlwZSBcIiR7dHlwZX1cIiBpcyBub3QgYSB2YWxpZCBBQkkgdHlwZS4gUGVyaGFwcyB5b3UgZm9yZ290IHRvIGluY2x1ZGUgYSBzdHJ1Y3Qgc2lnbmF0dXJlP2BcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbi8vIHNyYy9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaS50c1xuZnVuY3Rpb24gcGFyc2VBYmkoc2lnbmF0dXJlcykge1xuICBjb25zdCBzdHJ1Y3RzID0gcGFyc2VTdHJ1Y3RzKHNpZ25hdHVyZXMpO1xuICBjb25zdCBhYmkgPSBbXTtcbiAgY29uc3QgbGVuZ3RoID0gc2lnbmF0dXJlcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduYXR1cmVzW2ldO1xuICAgIGlmIChpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgICAgY29udGludWU7XG4gICAgYWJpLnB1c2gocGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzKSk7XG4gIH1cbiAgcmV0dXJuIGFiaTtcbn1cblxuLy8gc3JjL2h1bWFuLXJlYWRhYmxlL3BhcnNlQWJpSXRlbS50c1xuZnVuY3Rpb24gcGFyc2VBYmlJdGVtKHNpZ25hdHVyZSkge1xuICBsZXQgYWJpSXRlbTtcbiAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpXG4gICAgYWJpSXRlbSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIGVsc2Uge1xuICAgIGNvbnN0IHN0cnVjdHMgPSBwYXJzZVN0cnVjdHMoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBsZW5ndGggPSBzaWduYXR1cmUubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBzaWduYXR1cmVbaV07XG4gICAgICBpZiAoaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlXykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgYWJpSXRlbSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZV8sIHN0cnVjdHMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghYWJpSXRlbSlcbiAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEFCSSBpdGVtLlwiLCB7XG4gICAgICBkZXRhaWxzOiBgcGFyc2VBYmlJdGVtKCR7SlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlLCBudWxsLCAyKX0pYCxcbiAgICAgIGRvY3NQYXRoOiBcIi9hcGkvaHVtYW4uaHRtbCNwYXJzZWFiaWl0ZW0tMVwiXG4gICAgfSk7XG4gIHJldHVybiBhYmlJdGVtO1xufVxuXG4vLyBzcmMvaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlQYXJhbWV0ZXIudHNcbmZ1bmN0aW9uIHBhcnNlQWJpUGFyYW1ldGVyMihwYXJhbSkge1xuICBsZXQgYWJpUGFyYW1ldGVyO1xuICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiKVxuICAgIGFiaVBhcmFtZXRlciA9IHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtLCB7XG4gICAgICBtb2RpZmllcnNcbiAgICB9KTtcbiAgZWxzZSB7XG4gICAgY29uc3Qgc3RydWN0cyA9IHBhcnNlU3RydWN0cyhwYXJhbSk7XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyYW0ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHBhcmFtW2ldO1xuICAgICAgaWYgKGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgYWJpUGFyYW1ldGVyID0gcGFyc2VBYmlQYXJhbWV0ZXIoc2lnbmF0dXJlLCB7IG1vZGlmaWVycywgc3RydWN0cyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIWFiaVBhcmFtZXRlcilcbiAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEFCSSBwYXJhbWV0ZXIuXCIsIHtcbiAgICAgIGRldGFpbHM6IGBwYXJzZUFiaVBhcmFtZXRlcigke0pTT04uc3RyaW5naWZ5KHBhcmFtLCBudWxsLCAyKX0pYCxcbiAgICAgIGRvY3NQYXRoOiBcIi9hcGkvaHVtYW4uaHRtbCNwYXJzZWFiaXBhcmFtZXRlci0xXCJcbiAgICB9KTtcbiAgcmV0dXJuIGFiaVBhcmFtZXRlcjtcbn1cblxuLy8gc3JjL2h1bWFuLXJlYWRhYmxlL3BhcnNlQWJpUGFyYW1ldGVycy50c1xuZnVuY3Rpb24gcGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtcykge1xuICBjb25zdCBhYmlQYXJhbWV0ZXJzID0gW107XG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IHNwbGl0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChwYXJzZUFiaVBhcmFtZXRlcihwYXJhbWV0ZXJzW2ldLCB7IG1vZGlmaWVycyB9KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0cnVjdHMgPSBwYXJzZVN0cnVjdHMocGFyYW1zKTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHBhcmFtc1tpXTtcbiAgICAgIGlmIChpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBzcGxpdFBhcmFtZXRlcnMoc2lnbmF0dXJlKTtcbiAgICAgIGNvbnN0IGxlbmd0aDIgPSBwYXJhbWV0ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGVuZ3RoMjsgaysrKSB7XG4gICAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChcbiAgICAgICAgICBwYXJzZUFiaVBhcmFtZXRlcihwYXJhbWV0ZXJzW2tdLCB7IG1vZGlmaWVycywgc3RydWN0cyB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWJpUGFyYW1ldGVycy5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBBQkkgcGFyYW1ldGVycy5cIiwge1xuICAgICAgZGV0YWlsczogYHBhcnNlQWJpUGFyYW1ldGVycygke0pTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgMil9KWAsXG4gICAgICBkb2NzUGF0aDogXCIvYXBpL2h1bWFuLmh0bWwjcGFyc2VhYmlwYXJhbWV0ZXJzLTFcIlxuICAgIH0pO1xuICByZXR1cm4gYWJpUGFyYW1ldGVycztcbn1cbmV4cG9ydCB7XG4gIEJhc2VFcnJvcixcbiAgbmFycm93LFxuICBwYXJzZUFiaSxcbiAgcGFyc2VBYmlJdGVtLFxuICBwYXJzZUFiaVBhcmFtZXRlcjIgYXMgcGFyc2VBYmlQYXJhbWV0ZXIsXG4gIHBhcnNlQWJpUGFyYW1ldGVyc1xufTtcbiJdLCJuYW1lcyI6WyJieXRlc1JlZ2V4IiwiZXhlY1R5cGVkIiwiaW50ZWdlclJlZ2V4IiwiaXNUdXBsZVJlZ2V4IiwiX19wdWJsaWNGaWVsZCIsIm5hbWUiLCJ2ZXJzaW9uIiwiQmFzZUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInNob3J0TWVzc2FnZSIsImFyZ3MiLCJkZXRhaWxzIiwiY2F1c2UiLCJtZXNzYWdlIiwiZG9jc1BhdGgiLCJtZXRhTWVzc2FnZXMiLCJqb2luIiwibmFycm93IiwidmFsdWUiLCJlcnJvclNpZ25hdHVyZVJlZ2V4IiwiaXNFcnJvclNpZ25hdHVyZSIsInNpZ25hdHVyZSIsInRlc3QiLCJleGVjRXJyb3JTaWduYXR1cmUiLCJldmVudFNpZ25hdHVyZVJlZ2V4IiwiaXNFdmVudFNpZ25hdHVyZSIsImV4ZWNFdmVudFNpZ25hdHVyZSIsImZ1bmN0aW9uU2lnbmF0dXJlUmVnZXgiLCJpc0Z1bmN0aW9uU2lnbmF0dXJlIiwiZXhlY0Z1bmN0aW9uU2lnbmF0dXJlIiwic3RydWN0U2lnbmF0dXJlUmVnZXgiLCJpc1N0cnVjdFNpZ25hdHVyZSIsImV4ZWNTdHJ1Y3RTaWduYXR1cmUiLCJjb25zdHJ1Y3RvclNpZ25hdHVyZVJlZ2V4IiwiaXNDb25zdHJ1Y3RvclNpZ25hdHVyZSIsImV4ZWNDb25zdHJ1Y3RvclNpZ25hdHVyZSIsImZhbGxiYWNrU2lnbmF0dXJlUmVnZXgiLCJpc0ZhbGxiYWNrU2lnbmF0dXJlIiwicmVjZWl2ZVNpZ25hdHVyZVJlZ2V4IiwiaXNSZWNlaXZlU2lnbmF0dXJlIiwibW9kaWZpZXJzIiwiU2V0IiwiZXZlbnRNb2RpZmllcnMiLCJmdW5jdGlvbk1vZGlmaWVycyIsImdldFBhcmFtZXRlckNhY2hlS2V5IiwicGFyYW0iLCJ0eXBlIiwicGFyYW1ldGVyQ2FjaGUiLCJNYXAiLCJpbmRleGVkIiwicGFyc2VTaWduYXR1cmUiLCJzdHJ1Y3RzIiwibWF0Y2giLCJpbnB1dFBhcmFtcyIsInNwbGl0UGFyYW1ldGVycyIsInBhcmFtZXRlcnMiLCJpbnB1dHMiLCJpbnB1dExlbmd0aCIsImxlbmd0aCIsImkiLCJwdXNoIiwicGFyc2VBYmlQYXJhbWV0ZXIiLCJvdXRwdXRzIiwicmV0dXJucyIsIm91dHB1dFBhcmFtcyIsIm91dHB1dExlbmd0aCIsInN0YXRlTXV0YWJpbGl0eSIsInBhcmFtcyIsImFiaVBhcmFtZXRlcnMiLCJhYmlQYXJhbWV0ZXJXaXRob3V0VHVwbGVSZWdleCIsImFiaVBhcmFtZXRlcldpdGhUdXBsZVJlZ2V4IiwiZHluYW1pY0ludGVnZXJSZWdleCIsIm9wdGlvbnMiLCJwYXJhbWV0ZXJDYWNoZUtleSIsImhhcyIsImdldCIsImlzVHVwbGUiLCJpc1NvbGlkaXR5S2V5d29yZCIsIm5hbWUyIiwibW9kaWZpZXIiLCJjb21wb25lbnRzIiwiY29tcG9uZW50c18iLCJpc1NvbGlkaXR5VHlwZSIsImlzVmFsaWREYXRhTG9jYXRpb24iLCJhcnJheSIsImFiaVBhcmFtZXRlciIsInNldCIsInJlc3VsdCIsImN1cnJlbnQiLCJkZXB0aCIsInRyaW0iLCJjaGFyIiwidGFpbCIsInNsaWNlIiwicHJvdGVjdGVkS2V5d29yZHNSZWdleCIsImlzQXJyYXkiLCJwYXJzZVN0cnVjdHMiLCJzaWduYXR1cmVzIiwic2hhbGxvd1N0cnVjdHMiLCJzaWduYXR1cmVzTGVuZ3RoIiwicHJvcGVydGllcyIsInNwbGl0IiwicHJvcGVydGllc0xlbmd0aCIsImsiLCJwcm9wZXJ0eSIsInRyaW1tZWQiLCJyZXNvbHZlZFN0cnVjdHMiLCJlbnRyaWVzIiwiT2JqZWN0IiwiZW50cmllc0xlbmd0aCIsInJlc29sdmVTdHJ1Y3RzIiwidHlwZVdpdGhvdXRUdXBsZVJlZ2V4IiwiYW5jZXN0b3JzIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlQWJpIiwiYWJpIiwicGFyc2VBYmlJdGVtIiwiYWJpSXRlbSIsInNpZ25hdHVyZV8iLCJwYXJzZUFiaVBhcmFtZXRlcjIiLCJwYXJzZUFiaVBhcmFtZXRlcnMiLCJsZW5ndGgyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/abitype/dist/index.mjs\n");

/***/ })

};
;